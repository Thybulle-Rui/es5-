# JS数据结构与算法

## 1.java和js数组的区别

1.常见语言的数组不能存放不同的数据类型，因此所有在封装时通常存放在数组中的是Object类型

2.常见语言的数组容量不会改变（需要进行扩容操作）

3.常见语言的数据进行插入和删除操作性能较低

## 2.栈结构

数组是一种线性结构，可以在任意位置插入和删除数据

栈和队列比较常见的受限的线性结构，对插入和删除的任意性进行限制

栈只能在栈顶进栈和出栈

后进先出(LIFO)

**eg**

自助餐的托盘，最新放上去的，最先被客人拿走使用

收到很多的邮件，从上往下依次处理这些邮件



函数调用栈

A调用B， B中调用C，C调用D

A压入栈，B再压入栈-----

A在栈底，D在栈顶

D执行完，弹出栈。C/B/A依次弹出栈



递归如果单次效率很低，很容易溢出栈



**面试题**
有六个元素6,5,4,3,2,1的顺序进栈，请问下列哪一个不是合法的出栈顺序

A. 5 4 3 6 1  2	B. 4 5 2 3 1 6	C. 3 4 6 5 2 1 	D. 2 3 4 1 5 6

**解析**

A：5出栈，6压栈。所以一定是5出栈，4马上进栈；4出栈，3马上进栈。。

B： 4，5，6进栈，4，5出栈，3进栈，3出栈；。。

C： 3，4，5，6进栈，3，4出栈，6没法出栈，错误

D：。。。

**所以选C**



实现方式

1. 基于数组实现
2. 基于列表实现

栈的操作

	1. push
 	2. pop
 	3. peak：查看栈顶元素，不会做任何修改
 	4. isEmpty: 判断栈是否为空
 	5. size()
 	6. toString: 将栈结构的内容以字符形式返回



十进制转成二进制



## 3. 队列结构

首先的线性表，先进先出（FIFO）

受限之处在于它只允许在表的前端进行删除，

而在表的后端进行插入操作

**e.g.**

电影院，商场排队

打印队列

五份文档需要打印，依次放入到打印队列中

打印机会依次从队列中取出文档

**线程队列**

多线程，不能并行处理（太占内存）

开启线程处理任务的情况，就会使用线程队列

***击鼓传花***

很多人围成一圈，从某位同学手中向另外的同学传递花，一旦班长击鼓，那么将会 停止。

修改规则：

每个人开始数数，数到某个数字淘汰，最后剩下的人为获胜的人。



<h4>优先级队列</h4>

优先级队列在插入一个元素的时候会先考虑该数据的优先级

每个元素不在只是一个数据，而且包括优先级

{data: , priority: }

**example**

机场的登机顺序（头等舱和商务舱）

急诊科（病情严重）

线程（任务的重要性分布）



封装元素和优先级放在一起，封装一个新的构造函数

添加元素时，将新插入的优先级和已经存在的元素优先级比较。



## 链表

数组是最常用的数据结构

数组的缺点

- 创建需要一段连续的内存空间，并且大小是固定的，当数组不能满足时，需要进行扩容
- 在数组的开头或中间位置插入数据的成本很高，大量数据的移位

链表的优势：

- 存储多个元素，不必是连续的空间
- 一个存储元素本身的节点和指向下一个元素的引用
- 大小可以无限的延伸
- 充分利用计算的内存，实现灵活的内存动态管理
- 插入和删除数据时，时间复杂度为O(1)

链表的缺点：

- 访问元素需要从头开始访问
- 无法通过下标直接访问元素

链表类似于火车头

- 乘客：data
- 下一个节点：下一个火车头

![](D:\JavaScript数据结构算法\链表结构.png)

在LinkedList里面有一个Node类，用于封装每一个节点上面的信息

链表中我们保存两个属性，一个是链表的长度，一个是链表中的第一个节点。

链表的常见操作:

- append(element):向列表的尾部添加一个新的项
- insert(position, element)：将元素插入到相应位置，项指针变换
- get(position): 获取对应位置的元素
- indexof(element):根据元素，获取对应的索引值
- update(position): 修改某个位置的元素
- removeAt(position)：从列表的特定位置移除一列
- remove(element)：从列表中移除一项
- isEmpty
- size
- toString

append: 默认header指向null，根据数据创建节点，如果是第一个节点，需要让header指向当前节点。

如果不是第一个节点，创建节点，找到当前节点的上一个节点，next指针指向这个节点。

![](D:\JavaScript数据结构算法\链接append.png)



insert:

越界判断（负数，长度）

![](D:\JavaScript数据结构算法\链表insert1.png)

![](D:\JavaScript数据结构算法\链表insert2.png)

current是倒数第二个

只要让newNode介于倒数第二个和倒数第一个之间就行了



removeAt(position)
![](D:\JavaScript数据结构算法\链表RemoveAt.png)

和insert差不多，先用while(index < position)搜寻到当前位置的节点 



## 双向链表

单向链表：

- 只能从头遍历到尾或者从尾遍历到头
- 链表相连的过程是单向的
- 实现的原理是**上一个链表有指向下一个链表的引用**

缺点：

- 我们可以轻松的到达下一个节点，但是回到前一个节点是非常困难的。
- 但是实际开发中需要考虑双向的问题
- 如果向前遍历，需要从第一个节点开始从头循环。

双向链表：

- 既可以从头遍历到尾，又可以从尾遍历到头
- 一个节点既有向前连接的引用，也有一个向后连接的引用

缺点：

- 每次插入或者删除某个节点，需要处理四个引用，实现起来要困难一些
- 相对于单向链表，占用的内存更大了

![](D:\JavaScript数据结构算法\双向链表.png)

所以head和tail是两个额外的指针，永远指向第一个和最后一个，和元素本身的prev和next没关系

需要封装的方法和单项链表是相同的，

唯一不同的增加了两个方法

- forwardString()
- backwardString()

**append**

![](D:\JavaScript数据结构算法\双向链表--append.png)

有了尾指针，不需要从头遍历了，很方便。

**insert**

![](D:\JavaScript数据结构算法\双向链表--insert.png)

**removeAt**

![](D:\JavaScript数据结构算法\双向链表--removeAt.png)